import { stat } from "fs/promises";
import ts from "typescript";
export const TData = ts.factory.createIdentifier("TData");
export const TError = ts.factory.createIdentifier("TError");
export const TContext = ts.factory.createIdentifier("TContext");
export const queryKeyGenericType = ts.factory.createTypeReferenceNode("TQueryKey");
export const queryKeyConstraint = ts.factory.createTypeReferenceNode("Array", [
    ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword),
]);
export const capitalizeFirstLetter = (str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
};
export const lowercaseFirstLetter = (str) => {
    return str.charAt(0).toLowerCase() + str.slice(1);
};
export const getNameFromMethod = (method) => {
    return method.getName();
};
export async function exists(f) {
    try {
        await stat(f);
        return true;
    }
    catch {
        return false;
    }
}
const Common = "Common";
/**
 * Build a common type name by prepending the Common namespace.
 */
export function BuildCommonTypeName(name) {
    if (typeof name === "string") {
        return ts.factory.createIdentifier(`${Common}.${name}`);
    }
    return ts.factory.createIdentifier(`${Common}.${name.text}`);
}
/**
 * Safely parse a value into a number. Checks for NaN and Infinity.
 * Returns NaN if the string is not a valid number.
 * @param value The value to parse.
 * @returns The parsed number or NaN if the value is not a valid number.
 */
export function safeParseNumber(value) {
    const parsed = Number(value);
    if (!isNaN(parsed) && isFinite(parsed)) {
        return parsed;
    }
    return NaN;
}
export function extractPropertiesFromObjectParam(param) {
    const referenced = param.findReferences()[0];
    const def = referenced.getDefinition();
    const paramNodes = def
        .getNode()
        .getType()
        .getProperties()
        .map((prop) => ({
        name: prop.getName(),
        optional: prop.isOptional(),
        type: prop.getValueDeclaration()?.getType(),
    }));
    return paramNodes;
}
