import ts from "typescript";
export async function getServices(project) {
    const node = project
        .getSourceFiles()
        .find((sourceFile) => sourceFile.getFilePath().includes("services.ts"));
    if (!node) {
        throw new Error("No service node found");
    }
    const klasses = getClassesFromService(node);
    return {
        klasses: klasses.map(({ klass, className }) => ({
            className,
            klass,
            methods: getMethodsFromService(node, klass),
        })),
        node,
    };
}
function getClassesFromService(node) {
    const klasses = node.getClasses();
    if (!klasses.length) {
        throw new Error("No classes found");
    }
    return klasses.map((klass) => {
        const className = klass.getName();
        if (!className) {
            throw new Error("Class name not found");
        }
        return {
            className,
            klass,
        };
    });
}
function getClassNameFromClassNode(klass) {
    const className = klass.getName();
    if (!className) {
        throw new Error("Class name not found");
    }
    return className;
}
function getMethodsFromService(node, klass) {
    const methods = klass.getMethods();
    if (!methods.length) {
        throw new Error("No methods found");
    }
    return methods.map((method) => {
        const methodBlockNode = method.compilerNode
            .getChildren(node.compilerNode)
            .find((child) => child.kind === ts.SyntaxKind.Block);
        if (!methodBlockNode) {
            throw new Error("Method block not found");
        }
        const methodBlock = methodBlockNode;
        const foundReturnStatement = methodBlock.statements.find((s) => s.kind === ts.SyntaxKind.ReturnStatement);
        if (!foundReturnStatement) {
            throw new Error("Return statement not found");
        }
        const returnStatement = foundReturnStatement;
        const foundCallExpression = returnStatement.expression;
        if (!foundCallExpression) {
            throw new Error("Call expression not found");
        }
        const callExpression = foundCallExpression;
        const properties = callExpression.arguments[1].properties;
        const httpMethodName = properties
            .find((p) => p.name?.getText(node.compilerNode) === "method")
            ?.initializer?.getText(node.compilerNode);
        if (!httpMethodName) {
            throw new Error("httpMethodName not found");
        }
        const getAllChildren = (tsNode) => {
            const childItems = tsNode.getChildren(node.compilerNode);
            if (childItems.length) {
                const allChildren = childItems.map(getAllChildren);
                return [tsNode].concat(allChildren.flat());
            }
            return [tsNode];
        };
        const children = getAllChildren(method.compilerNode);
        const jsDoc = method.getJsDocs().map((jsDoc) => jsDoc);
        const isDeprecated = children.some((c) => c.kind === ts.SyntaxKind.JSDocDeprecatedTag);
        const className = getClassNameFromClassNode(klass);
        return {
            className,
            node,
            method,
            methodBlock,
            httpMethodName,
            jsDoc,
            isDeprecated,
        };
    });
}
